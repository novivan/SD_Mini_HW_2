# SD_Mini_HW_2
Мини-ДЗ 2 по КПО

## Инструкции:
---
Для запуска перейдите в директорию с проектом:
```
cd sd_mini_2
```
Компиляция и запуск проекта с Spring:
```
mvn spring-boot:run
```
Протестировать приложение через UI можно, перейдя после запуска по ссылке:
```
http://localhost:8080
```
Если по этой ссылке после запуска не откроется, стоит поискать в логах запуска строчку:
```
Tomcat started on port(s): n (http) with context path 'x'
```
Тогда нужно будет перейти по ссылке:
```
http://localhost/<x>:<n>
```

После запуска приложения Swagger UI будет доступен по адресу: 
```
http://localhost:8080/swagger-ui.html
```
(или вместо 8080 нужно будет вставить n, если выделится другой порт)

---
## Отчет:

### a. Реализованный функционал

1. **Добавление/удаление животных**
   - Класс `AnimalController` - REST API для работы с животными
   - Класс `WebAnimalController` - веб-интерфейс для работы с животными
   - Методы: `createAnimal`, `getAllAnimals`, `getAnimal`, `deleteAnimal`

2. **Добавление/удаление вольеров**
   - Класс `EnclosureController` - REST API для работы с вольерами
   - Класс `WebEnclosureController` - веб-интерфейс для работы с вольерами
   - Методы: `createEnclosure`, `getAllEnclosures`, `getEnclosure`, `deleteEnclosure`

3. **Перемещение животных между вольерами**
   - Класс `AnimalTransferService` - сервис для перемещения животных
   - Класс `WebAnimalController` - метод `moveAnimal` для веб-интерфейса
   - Метод `addAnimal` в классе `Enclosure` для проверки совместимости животных

4. **Просмотр расписания кормления**
   - Класс `FeedingController` - REST API для работы с расписанием кормления
   - Класс `WebFeedingController` - веб-интерфейс для работы с расписанием
   - Методы: `getAllFeedings`, `getFeeding`

5. **Добавление кормления в расписание**
   - Класс `FeedingOrganizationService` - сервис для организации кормления
   - Метод `createFeeding` в контроллерах для добавления кормления

6. **Просмотр статистики зоопарка**
   - Класс `ZooStatisticsService` - сервис для сбора статистики
   - Класс `StatisticsController` и `WebStatisticsController` для отображения статистики
   - Методы для сбора различных статистических данных: кол-во животных, занятость вольеров, распределение по видам и статусам здоровья

### b. Применение концепций DDD и принципов Clean Architecture

#### Domain-Driven Design:

1. **Богатая доменная модель**
   - Класс `Animal` - инкапсулирует логику кормления, лечения и изменения статуса
   - Класс `Enclosure` - содержит бизнес-правила добавления и удаления животных, проверки совместимости
   - Класс `FeedingSchedule` - управляет процессом кормления

2. **Value Objects**
   - `AnimalSpecies` - виды животных как Value Object
   - `FoodType` - типы пищи как Value Object
   - `Gender` - пол животного как Value Object
   - `HealthStatus` - статус здоровья как Value Object
   - `EnclosureType` - тип вольера как Value Object
   
   Все Value Objects представляют неизменяемые концепции предметной области и заменяют примитивы.

3. **Доменные события**
   - `AnimalMovedEvent` - событие при перемещении животного
   - `FeedingTimeEvent` - событие при наступлении времени кормления

4. **Агрегаты и границы согласованности**
   - `Animal` как агрегат, управляющий состоянием здоровья, перемещениями
   - `Enclosure` как агрегат, контролирующий совместимость животных

5. **Репозитории**
   - Интерфейсы репозиториев в Domain слое: `AnimalRepository`, `EnclosureRepository`, `FeedingScheduleRepository`
   - Реализации в Infrastructure слое: `InMemoryAnimalRepository`, `InMemoryEnclosureRepository`, `InMemoryFeedingScheduleRepository`

#### Clean Architecture:

1. **Разделение на слои**
   - **Domain** - ядро системы с бизнес-логикой (модели, интерфейсы репозиториев)
   - **Application** - сервисы приложения, использующие Domain-модели
   - **Infrastructure** - внешние взаимодействия и реализация репозиториев
   - **Presentation** - контроллеры REST API и веб-интерфейса

2. **Зависимости направлены внутрь**
   - Domain не зависит от других слоев
   - Application зависит только от Domain
   - Infrastructure и Presentation зависят от внутренних слоев (Domain, Application)

3. **Инверсия зависимостей**
   - Интерфейсы репозиториев определены в Domain, реализации в Infrastructure
   - Сервисы в Application работают с интерфейсами репозиториев, не зная их реализации

4. **Изоляция бизнес-логики**
   - Бизнес-правила изолированы в Domain и Application слоях
   - Presentation и Infrastructure слои не содержат бизнес-логики

5. **Тестируемость**
   - Благодаря слоистой архитектуре, Domain и Application можно тестировать независимо от UI и базы данных
   - В проекте используется In-Memory реализация репозиториев, что упрощает тестирование

Эта архитектура обеспечивает:
- Гибкость - возможность легко заменять компоненты системы
- Тестируемость - возможность тестировать бизнес-логику отдельно от UI и инфраструктуры
- Поддерживаемость - изменения в одном слое не влияют на другие слои

